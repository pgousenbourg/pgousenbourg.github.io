<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd>
<html lang="en">
<head>
	<!-- UTF-8 incoder, compatibily with edge, responsive -->
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />	
	<meta http-equiv="X-UA-Compatible" content="IE=edge">	
	<meta name="viewport" content="width=device-width, initial-scale=1" />
	<!-- Document metadata -->
	<meta name="author" content="Pierre-Yves Gousenbourger" />
	<meta name="description" content="Research web page of Pierre-Yves Gousenbourger" />
	<meta name="keywords" content="Interpolation on manifolds,Riemannian manifolds,curve fitting,Bezier curves">
	
  <!-- Tags for social medias -->
  <!--  Essential META Tags -->
  <meta property="og:title" content="Pierre-Yves Gousenbourger, researcher and teaching assistant.">
  <meta property="og:description" content="Pierre-Yves Gousenbourger is a senior researcher in Engineering (Applied Mathematics) and a teaching assistant at UCLouvain, Belgium. Discover his last publications, work summaries and numerical tours on this webpage.">
  <meta property="og:image" content="https://perso.uclouvain.be/pygousenbourger/pics/hybrid_curve_code_logo.gif">
  <meta property="og:url" content="https://perso.uclouvain.be/pygousenbourger/">
  <meta name="twitter:card" content="summary_large_image">


  <!--  Non-Essential, But Recommended -->
  <meta property="og:site_name" content="Research web page of Pierre-Yves Gousenbourger.">
  <meta name="twitter:image:alt" content="Pierre-Yves Gousenbourger">
  
	<!-- Title -->
	<title>
		Pierre-Yves Gousenbourger, Applied Mathematics
	</title>
	
	<!-- Fonts -->
	<link href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:300" rel="stylesheet" type="text/css">
	<link href="https://fonts.googleapis.com/css?family=Roboto+Slab" rel="stylesheet">
	
	<!-- CSS -->
	<link rel="stylesheet" href="utils/gousenbourger-styles2.css">
	
	<!-- Favicon -->
	<link rel="shortcut icon" href="pics/favicon.ico">
  
  <!-- Awesome icons -->
  <script src="https://kit.fontawesome.com/03ffe86071.js" crossorigin="anonymous"></script>
	
	<!-- Javascript for math -->
	<!-- <script type="text/javascript" src="http://latex.codecogs.com/latexit.js"></script> -->
	<script type="text/x-mathjax-config">
			MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});
	</script>
	<script type="text/javascript" async
			src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_CHTML">
	</script>
</head>









<!-- Here is the beginning of the content -->
<body>
	<div class="centered">
		<!-- Header -->	
		<header>
      <div class="myname">
        <p class="name">Pierre-Yves Gousenbourger</p>
        <p class="subname">Teaching assistant at Université catholique de Louvain</p>
        <!-- when size < 950px -->
        <p class="subname_950">T.A. at Université catholique de Louvain</p> 
        <!-- when size < 800px -->
        <p class="subname_800">T.A. at UCLouvain</p>
      </div>
      <a href="http://www.uclouvain.be/icteam/"><img title="ICTEAM" class="rounded-pic icteam" src="pics/icteam.png" width=100%/></a>
    </header>

		
    
    
    
    
    
    
    
    
    
    
  <!-- Navigation --> 	
	<!-- Navigation. Copy-past this on every page. -->
	<nav class="largeScreen">	
    <ul>
      <li>
        <a href="index.html"><i class="fa fa-user"></i>About</a>
      </li>
      <li>
        <a href="research.html"><i class="fas fa-microscope"></i>Research</a>
      </li>
      <li>
        <a href="teaching.html"><i class="fas fa-graduation-cap"></i>Teaching</a>
      </li>
      <li>
        <a href="publications.html"><i class="fas fa-book"></i>Publications</a>
      </li>
      <li class="active">
        <a href="nt.html"><i class="fab fa-codepen"></i>Numerical tour</a>
      </li>
      <li>
        <a href="contact.html"><i class="far fa-address-card"></i>Contact</a>
      </li>
    </ul>
	</nav>
	<nav class="smallScreen">	
    <input type="checkbox" id="menu__active"/>
    <label for="menu__active" class="menu__active">
      <div class="menu__toggle">
        <div class="icon">
          <div class="hamburger"></div>
        </div>
      </div>
      <!-- Hidden menu for small devices -->
      <div class="menu__overlay">
        <!-- Overlay content -->
        <div class="overlay-content">
          <a href="index.html"><i class="fa fa-user"></i>About</a>
          <a href="research.html"><i class="fas fa-microscope"></i>Research</a>
          <a href="teaching.html"><i class="fas fa-graduation-cap"></i>Teaching</a>
          <a href="publications.html"><i class="fas fa-book"></i>Publications</a>
          <a href="nt.html"><i class="fab fa-codepen"></i>Numerical tour</a>
          <a href="contact.html"><i class="far fa-address-card"></i>Contact</a>
        </div>
      </div>
    </label>
	</nav>
	<!-- End of navigation -->
        
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
		<!-- Numerical tour -->
		<div name="Numerical Tour" id="sec-nt" class="tab">

      <!-- Surfaces -->
      <section>
        <aside class="image-left"><a href="http://nl.mathworks.com"><img title="Matlab" class="rounded-pic" src="pics/matlab.png" width=100%/></a></aside>
        
        <article>
          <p class="subtitle">
            Bidimensional interpolation with Bézier spline
          </p>
          <p>
            We are given a set of data points in the Euclidean space associated with two timestamps (m,n) organised on a regular grid. These timestamps give the order in which points must be interpolated. In this problem, for visualization convenience and without loss of generality, the (x,y) value of the data points correspond to the regular grid (m,n) and the z-value is randomly chosen. The points are organized in a 2D-cell corresponding to the order of interpolation.</p>
          <p>
            From these data points, the goal here is to draw a 2d-Bézier spline interpolating those in a $C^1$ way. For this, you can use our code here, general for manifolds. The possible manifolds are the Euclidean space, the sphere and the special orthogonal group SO(3).</p>
          
          <a href="codes/bezier-surface.zip">Download the code.</a>
          <p class="more" onclick="$('#nt-bezier-surfaces').slideToggle(400);">Show/hide the code tutorial.</p>

          <!-- The tour -->
          <div style="display: none" id="nt-bezier-surfaces">
            <h2 class="code">The code</h2>
              <p>Here is the code for interpolating data with a 2d-Bézier spline.</p>

<pre class="codeinput"><span class="comment">% Some random data points.</span>
m = 6; n = 7;
data = cell(m,n);
<span class="keyword">for</span> i=1:m
<span class="keyword">for</span> j=1:n
  data{i,j} = [i-1,j-1,randn(1)];
<span class="keyword">end</span>
<span class="keyword">end</span>

<span class="comment">% Some useful information...</span>
manifold = <span class="string">'euclidean'</span>;
set_path
global_variables
geo_functions

<span class="comment">% Create the problem structure.</span>
problem  = prepare_structure(data,manifold,10);

<span class="comment">% Phase 1: Control points generation.</span>
problem = control_points_simple_generation_2d(problem);

<span class="comment">% Phase 2: Reconstruction of the curve.</span>
problem = curve_reconstruction_double_bezier_c1(problem,1); <span class="comment">% horizontal-vertical</span>

<span class="comment">% Plotting</span>
figure;
draw_bezier_surface(problem);
title([<span class="string">'Bezier surface with method: '</span>,problem.method,<span class="string">'.'</span>]);</pre>

              <p>Okay, let's dig a bit into that...</p>
              


            <h2 class="code">Data points</h2>
              <p>As mentionned, the data points must be stored in a 2d-cell. Let's construct a random set of data points where the (x,y)-values correspond to (m,n) and the z-value is random.</p>
              <p>Hint: You may also call <code>data_points_2d(manifold,type)</code> to create some predefined test sets.</p>
              

<pre class="codeinput">m = 6; n = 7;
data = cell(m,n);
<span class="keyword">for</span> i=1:m
<span class="keyword">for</span> j=1:n
  data{i,j} = [i-1,j-1,randn(1)];
<span class="keyword">end</span>
<span class="keyword">end</span></pre>
              
            <h2 class="code">Problem structure preparation</h2>
              <p>The system is based on a structure called successively by different subfunctions in matlab. Each subfunction will use elements of differential geometry (the exponential, the logarithm, the distance, etc.). This is why this preparation step is crucial in order to inform the computer on the paths needed (the script set_path depends on the manifold) and on the elements of differential geometry available for the code (global_variables and geo_functions depend on the manifold).</p>
              
<pre class="codeinput">manifold = <span class="string">'euclidean'</span>;

<span class="comment">% define the paths where the manifold-tools are stored</span>
set_path
<span class="comment">% define the global variables, i.e. the elements of differential geometry.</span>
global_variables
geo_functions</pre>
              
              <p>Create the problem structure.</p>
              
<pre class="codeinput"><span class="comment">% the structure stored the name of the manifold, the data points and the discretization of the surface when reconstructed.</span>
problem  = prepare_structure(data,manifold,10);</pre>
              
              <p>The structure should look like</p>
              
<pre class="codeoutput">problem = 				
interp: {6x7 cell}
type: ''
manifold: 'euclidean'
   n: 6
   m: 7
dim1: 1
dim2: 3
   d: []
   t: 10
nint: 0</pre>
            
            
            <h2 class="code">Bézier spline optimization and reconstruction</h2>
              <p>The interpolation problem works in two steps: </p>
              <ol>
                <li>find the control points leading the Bézier curve</li>
                <li>reconstruct the actual spline.</li>
              </ol>
              
            
            <h3 class="code">Phase 1: Control points generation</h3>
              <p>The subfunction takes the structure as entry and will update it by adding the computed control points.</p>
              
<pre class="codeinput">problem = control_points_simple_generation_2d(problem);</pre>
              
              <p>There exist different methods to compute the control points:</p>
              <ul>
                <li>
                  <code>control_points_generation(problem)</code>: By an exact technique minimizing the Euclidean acceleration of the path. Warning, this technique is costly in time when the log and exp are not trivial. The technique is documented in the <a href="http://sites.uclouvain.be/absil/2015.10">technical report of 2015</a>.
                </li>
                <li>
                  <code>control_points_simple_generation_2d(problem)</code> With an efficient but not perfect algorithm based on the B-spline representation of curves generalized to surfaces. This technique is documented in <a href="#research">ESANN2016</a>
                </li>
                <li>
                  <code>control_points_double_tensorization(problem)</code> With the same efficient algorithm but applied to 1D curves horizontally and then vertically. The technique is also documented in <a href="#research">ESANN2016</a>
                </li>
              </ul>
              <p>In the Euclidean space, all these techniques are identical.</p>
              
            <h3 class="code">Phase 2: Reconstruction of the curve</h3>
              <p>Here also, the subfunction takes the structure as entry and will update it by adding the computed spline. If the structure does not contain the control points, the reconstruction is not possible.</p>
<pre class="codeinput">problem = curve_reconstruction_double_bezier_c1(problem,1); <span class="comment">% horizontal-vertical</span></pre>

              <p>There also exist different techniques to reconstruct the Bézier spline. The following ones return a C^1 surface. They are documented in <a href="http://sites.uclouvain.be/absil/2015.10">technical report of 2015</a>.</p>
              <ul>
                <li>
                  <code>curve_reconstruction_mean_all_c1(problem)</code> uses the altered defintion of Bezier surfaces based on averaging of all control points of the patch.
                </li>
                <li>
                  <code>curve_reconstruction_double_bezier_c1(problem,k)</code> uses the altered definition of Bezier curves horizontal-vertical (k=1) or vertical-horizontal (k=2) depending on the argument.
                </li>
              </ul>	
              <p>The two following ones return a C^0 surface and their limits are also discussed in the <a href="http://sites.uclouvain.be/absil/2015.10">technical report of 2015</a>.</p>
              
              <ul>
                <li>
                  <code>curve_reconstruction_mean_all(problem)</code> uses the basic definition of Bezier surfaces based on averaging of all the points of the patch.
                </li>
                <li>
                  <code>curve_reconstruction_double_bezier(problem,k)</code> uses the basic definition of Bezier curves horizontal-vertical (1) or vertical-horizontal (2) depending on the argument.
                </li>
              </ul>
            
            <h2 class="code">Plotting</h2>
              <p>We propose a method to plot the solution. The plotting method is chosen based on the manifold and on the paths set at the beginning.</p>
<pre class="codeinput">figure;
draw_bezier_surface(problem);
title([<span class="string">'Bezier surface with method: '</span>,problem.method,<span class="string">'.'</span>]);
</pre>
              <p><img src="pics/nt_eucl_2d_surface.png" class="rounded-pic" width=100%/></p>
          </div>

        </article> <!-- corps -->
      </section>










      <!-- Hybrid -->
      <section>
        <aside class="image-left"><img title="interpolation morphing" class="rounded-pic" src="pics/hybrid_curve_code_logo.gif" width=100%/></aside>
        
        <article>
          <p class="subtitle">
            Unidimensional interpolation with hybrid composite Bézier curves
          </p>
          <p>
            We are given a set of data points in the Euclidean space associated with a timestamp $t_i \in \mathbb{Z}$. We would like to compute a composite Bézier curve that interpolates the data points $d_i$ at time $t_i$. In this problem, we try to interpolate four data points $d_i \in \mathbb{S}^2$, the unit sphere. These points are places such that they represent a triangle.</p>
          <p>
            To fit the curve $\mathfrak{B}(t): [0,3] \to \mathbb{S}^2$, you can use our code here, general for manifolds. The possible manifolds are the Euclidean space, the sphere, the special orthogonal group SO(3),... actually all manifolds you can find in Manopt are operational. It is however mandatory to add manopt to your working path. The zip file hereunder contains an old version of Manopt for consistency. You can download the last version of Manopt here (recommended) : <a href="www.manopt.org">www.manopt.org</a>.
          </p>
          
          <a href="codes/toolbox_1d_hybride.zip">Download the code.</a>
          <p class="more" onclick="$('#nt-interp_hybrid_curves').slideToggle(400);">Show/hide the code tutorial.</p>
          
          <!-- The tour -->
          <div style="display: none" id="nt-interp_hybrid_curves">
            <h2 class="code">The code</h2>
              <p>Here is the code for interpolating data with a hybrid composite Bézier curve on the sphere.</p>

<pre class="codeinput"><span class="comment">% Add the paths for manopt and for the tools</span>
cd manopt;
addpath(genpath(pwd));
cd ..;
addpath(genpath([pwd,'/tools']));
  
<span class="comment">% Some data points on the sphere.</span>
phi     = [pi/3 ; 4*pi/7 ; 4*pi/7 ; pi/3] - 2*pi/12; 
theta   = [pi/2 ; pi/4 ; 3*pi/4 ; pi/2] + 10*pi/12;
x       = cos(theta).*sin(phi); y = sin(theta).*sin(phi); z = cos(phi);
points  = [x y z];
data    = reshape(points',1,3,4);

<span class="comment">% Problem parameters</span>
n = size(data,3);
t = linspace(0,n-1,100);

<span class="comment">% Structure creation</span>
problem.M = spherefactory(3);
problem.data = data;

<span class="comment">% Phase 1: Control points generation.</span>
problem.control = cp_arnould(problem);

<span class="comment">% Phase 2: Reconstruction of the curve.</span>
problem = bezier_reconstruction(problem,t);

<span class="comment">% Optional: velocity and acceleration computation.</span>
problem.velocity = bezier_velocity(problem,t);
problem.acceleration = bezier_acceleration(problem,t);
  
<span class="comment">% Plotting</span>
y = squeeze(problem.curve)'; b = squeeze(problem.control)'; p = squeeze(problem.data)';	
a = problem.acceleration; v = problem.velocity;

[X,Y,Z] = sphere(); 
figure;
subplot(2,2,[1 3]); surf(0.95*X,0.95*Y,0.95*Z,...
    <span class="string">'FaceAlpha'</span>,0.7,<span class="string">'EdgeAlpha'</span>,1,...
    <span class="string">'FaceColor'</span>, [238 197 145]/255);
  hold on;
  plot3(y(:,1),y(:,2),y(:,3),<span class="string">'b'</span>,<span class="string">'LineWidth'</span>,2);
  plot3(b(:,1),b(:,2),b(:,3),<span class="string">'.'</span>,<span class="string">'Color'</span>,[0 0.7 0],<span class="string">'Markersize'</span>,30);
  plot3(p(:,1),p(:,2),p(:,3),<span class="string">'.r'</span>,<span class="string">'Markersize'</span>,30);
  title(<span class="string">'Bezier spline'</span>);
subplot(222); plot(t(2:end-1),v,<span class="string">'-b'</span>,<span class="string">'LineWidth'</span>,2); title(<span class="string">'velocity'</span>);
subplot(224); plot(t(2:end-1),a,<span class="string">'-b'</span>,<span class="string">'LineWidth'</span>,2); title(<span class="string">'acceleration'</span>);</pre>

              <p>Okay, let's dig a bit into that...</p>
              


            <h2 class="code">Data points</h2>
              <p>The data points must be stored in a (l,c,n) matrix, where (l,c) is the matrix size of the embedded space. Here, for the sphere, it would be (1,3), as $\mathbb{S}^2$ is embedded in $\mathbb{R}^3$. The points here are draw a triangle on the sphere, and the first and last points coincide.</p>
              <p>Hint: You may also call <code>data_points(manifold,type)</code> to create some predefined test sets. Do not forget to add the path to it (<code>addpath([pwd,'/data_points']);</code>).</p>

<pre class="codeinput"><span class="comment">% Some data points on the sphere.</span>
phi     = [pi/3 ; 4*pi/7 ; 4*pi/7 ; pi/3] - 2*pi/12; 
theta   = [pi/2 ; pi/4 ; 3*pi/4 ; pi/2] + 10*pi/12;
x       = cos(theta).*sin(phi); y = sin(theta).*sin(phi); z = cos(phi);
points  = [x y z];
data    = reshape(points',1,3,4);</pre>
              
            <h2 class="code">Problem structure preparation</h2>
              <p>The system is based on a structure called successively by different subfunctions in matlab. Each subfunction will use the elements of differential geometry (the exponential, the logarithm, the distance, etc.) extracted from Manopt and stored in that structure. The names of the different elements of the structure will be very important as they are used by the rest of the code later on.</p>
              
              <p>We prepare first the time parameter <code>t</code> to be able, later on, to compute the reconstruction spline. Typically, it is a discretization of the domain (here $t \in [0,3]$).</p>
              
<pre class="codeinput"><span class="comment">% Problem parameters</span>
n = size(data,3);
t = linspace(0,n-1,100);</pre>
              
              <p>Now, we store the crucial information in a structure.</p>
              
<pre class="codeinput"><span class="comment">% Structure creation</span>
problem.M = spherefactory(3);
problem.data = data;</pre>
              
              <p>The structure <code>problem</code> is supposed to be at the end composed of the following elements (in this specific problem):</p>
              
<pre class="codeoutput">problem = 				
            data: [1×3×4 double]
               M: [1×1 struct]
         control: [1×3×8 double]
           curve: [1×3×100 double]
        velocity: [98×1 double]
    acceleration: [98×1 double]
</pre>
              
              <p>The data points are stored in the field <code>data</code>, the control points in <code>control</code>, the curve in <code>curve</code> and the manifold in <code>M</code>. It is important to respect these four names. The other names have less importance.</p>
            
            
            <h2 class="code">Bézier curve optimization and reconstruction</h2>
              <p>The interpolation problem works in two steps: </p>
              <ol>
                <li>find the control points leading the Bézier curve</li>
                <li>reconstruct the actual spline.</li>
              </ol>
              
            
            <h3 class="code">Phase 1: Control points generation</h3>
              <p>The subfunction takes the structure as entry and will return the control points. Store it in the structure for reconstruction.</p>
              
<pre class="codeinput">problem.control = cp_arnould(problem);</pre>
              
              <p>There exist different methods to compute the control points:</p>
              <ul>
                <li>
                  <code>cp_arnould(problem)</code>: technique proposed in the paper <a href="#research">Arnould et al. 2015</a>. This technique is recommended.
                </li>
                <li>
                  <code>cp_gousenbourger(problem)</code>: suboptimal technique proposed in the paper <a href="#research">Gousenbourger et al. 2014</a>, where the velocity vectors must be specified in the beginning of the method. It works but... well, there is better, so why not using it ? ;-).
                </li>
              </ul>
              
            <h3 class="code">Phase 2: Reconstruction of the curve</h3>
              <p>Here also, the subfunction takes the structure as entry and will update it by adding the computed spline. If the structure does not contain the field <code>control</code>, filled with the control points returned by the control points generation method, the reconstruction is not possible.</p>
<pre class="codeinput">problem = bezier_reconstruction(problem,t);</pre>

              <p>The method is a simple De Casteljau algorithm adapted to compute a hybrid composite Bézier curve.</p>
            
            <h2 class="code">Optional phase: Acceleration and velocity of the curve</h2>
              <p>Once the curve is reconstructed, we offer a generic code to evaluate the velocity and the acceleration of the curve. Just use the following piece of code:</p>
<pre class="codeinput">a = bezier_velocity(problem,t);
v = bezier_acceleration(problem,t);</pre>
              
              <p>Be sure that the field <code>curve</code> is available in the structure <code>problem</code>.</p>


              <p>The rest is just plotting the curve on a sphere. Try it :-) !</p>

              <p><img src="pics/nt_sphere_hybrid_interp.png" class="rounded-pic" width=100%/></p>
          </div>
        </article> <!-- corps -->
      </section>
      
      
      
      




      
      <section style="margin-top:50pt;">
        <aside class="image-left"><a href="http://nl.mathworks.com"><img title="GPL-v3" class="rounded-pic" src="pics/gplv3.png" width=100%/></a></aside>
        
        <article>
          <p class="subtitle">
            License
          </p>
          <p>
            The code provided here is copyright and distributed under the terms of the <a href="http://www.gnu.org/licenses/gpl.html">GNU General Public License</a> (GPL) version 3 (or later).
          </p>
          <p>
            In short, this means that everyone is free to use the provided code, to modify it and to redistribute it on a free basis.
            However, this code is not in the public domain; it is copyrighted and there are restrictions on its distribution 
            (see the license and the related <a href="http://www.gnu.org/copyleft/gpl-faq.html">frequently asked questions</a>). 
            For example, you cannot integrate this version of the code (in full or in parts) 
            in any closed-source software you plan to distribute (commercially or not). Please contact me for more information.
          </p>
        </article> <!-- corps -->
      </section>
      
      <section>
        <p>This section was inspired by the very good <a href="http://www.gpeyre.com/">Gabriel Peyré's</a> Numerical Tours.</p>
      </section>
      
    </div><!-- Numerical tour -->




		
		<!-- Footer -->
		<footer>
			Created and designed by Pierre-Yves Gousenbourger.<br/>
			Last update: August 13, 2020.
		</footer>








    <!-- =================      Javascript      ==================== -->
    <!--    a little bit of scripting for the menu: Thx Matthew !    -->
    <!-- =========================================================== -->

    <!-- Utils for show-hide and tex -->
    <script src="utils/jquery.min.js"></script>
    <script src="utils/bootstrap.min.js"></script>    

	</div>
</body>
</html>
<!-- end of document -->
